# Background
- Program must be brought from disk into memory and placed within a process for it to be run
- Main memory and registers are only storage CPU can access directly
- Memory unit only sees a stream of:
	- Addresses + read requests, or
	- Address + data and write requests
- Register access is done in one CPU clock (or less)
- Main memory can take many cycles, causing a **stall**
- **Cache** sits between main memory adn CPU registers
- Protection of memory required to ensure correct operation
## Protection
- Need to ensure that a process can access only access those addresses in its address space
- We can provide this protection by using a pair of **base** and **limit registers** to define the logical address space of a process
- ![[Pasted image 20221107103022.png]]
- Very simple, not actually used in the real world
## Hardware Address Protection
- CPU must check every memory access generated in user mode to be sure it is between base and limit for that user
- ![[Pasted image 20221107103235.png]]
- the instructions to loading the base and limit registers are privileged
## Address Binding
- Programs on disk, ready to be brought into memory to execute from an **input queue**
	- Without support, must be loaded into a fixed address
- Inconvenient to have first user process physical address always at fixed addresses
	- How can it not be?
- Addresses represented in different ways at different stages of a program's life
	- Source code address usually symbolic
	- Compiled code address **bind** to relocatable addresses
		- i.e. "14 bytes from beginning of this module"
	- Linker or loader will bind relocatable addresses to absolute addresses
		- i.e. 74014
	- Each binding maps on address space to another
## Binding of Instructions and Data to Memory
- ![[Pasted image 20221107104215.png]]
## Logical vs. Physical Address Space
- The concept of a logical address space that is bound to a separate **physical address space** is central to proper memory management
	- **Logical address** - generated by the CPU; also referred to as **virtual address**
	- **Physical address** - address seen by the MU
- Logical and physical addresses are the same in compile-time and load-time address-binding schemes; logical (virtual) and physical addresses differ in execution-time address-binding scheme
- **Logical address space** is the set of all logical addresses generated by a program
- **Physical address space** is the set of all physical addresses generated by a program
## Memory-Management Unit (MMU)
- Hardware device that at run time maps virtual to physical address
- ![[Pasted image 20221107104802.png]]
- Many methods possible, covered in the rest of this chapter
- Consider simple scheme. which is a generalization of the base-register scheme.
- The base register now called **relocation register**
- The value in the relocation register is added to every address generated by a user process at the time it is sent to memory
- The user program deals with logical addresses; it never see the real physical addresses
	- Execution-time binding occurs when reference is made to location in memory
	- Logical address bound to physical addresses
- ![[Pasted image 20221107105105.png]]
## Dynamic Loading
- The entire program does need to be in memory to execute
- Routine is not loaded until it is called
- Better memory-space utilization; unused routine is never loaded
- All routines kept on disk in relocatable load format
- Useful when large amounts of code are needed to handle infrequently occuring cases
- No special support from the OS is required
	- Implemented through program design
	- OS can help by providing libraries to implement dynamic loading
## Dynamic Linking
- **Static linking** - system libraries and program code combined by the loader into the binary program image
- Dynamic linking - linking postponed until execution time
- Small piece of code, **stub**, used to locate the appropriate memory-resident library routine
- Stub replaces itself with the address of the routine, and executes the routine
- OS checks if routine is in processes' memory address
	- If not in address space, add to address space
- Dynamic linking is particularly useful for libraries
- System also known as **shared libraries**
- Consider applicability to patching system libraries
	- Versioning may be needed
# Contiguous Memory Allocation
- Main memory must support both OS and user processes
- Limited resource, must allocate efficiently
- Contiguous allocation is one early method
- Main memory usually into two **partitions**:
	- Resident OS, usually held in low memory with interrupt vector
	- User processes then held in high memory
	- Each process contained in single contiguous section of memory
- Relocation registers used to protect user processes from each other, and from changing OS code and data
	- Base register contains value of smallest physical address
	- Limit register contains range of logical addresses -each logical address must be less than the limit register
	- MMU maps logical address *dynamically*
	- Can then allow actions such as kernel code being **transient** and kernel changing size
- ![[Pasted image 20221107110401.png]]
## Variable Partition
- Multiple-partition allocation
	- Degree of multiprogramming limited by number of partitions
	- **Variable-partition** sizes for efficiency (sized to a given process' needs)
	- **Hole** - block of available memory; holes of various size are scattered throughout memory
	- When a process arrives, it is allocated memory from a hole large enough to accomodate it
	- Process exiting frees it partition, adjacent free partitions combined
	- OS maintains information about:
		1. Allocated partitions
		2. Free partitions (hole)
	- ![[Pasted image 20221107110807.png]]
## Dynamic Storage-Allocation Problem
- How to satisfy a request of size **n** from a list of free holes?
	- **First-fit**: Allocate the **first** hole that is big enough
	- **Best-fit**: Allocate the **smallest** hole that is big enough; must search entire list, unless ordered by size
		- Produces the smallest leftover hole
	- **Worst-fit**: Allocate the largest hole; must also search entire list
		- Produces the largest leftover hole
- First-fit and best-fit better than worst-fit in terms of speed and storage utilization
## Fragmentation
- **External Fragmentation** - total memory space exists to satisfy a request, but it is not contiguous
- **Internal Fragmentation** - allocated memory may be slightly larger than request memory; this size difference is larger than requested memory; this size difference is memory internal to a partition, but not being used
- First fit analysis reveals taht given N blocks allocated, 0.5 N blocks lost to fragmentation
	- 1/3 may be unstable -> 50% rule
- Reduce external fragmentation by **compaction**
	- Shuffle memory contents to place all free memory together in one large block
	- Compaction is possible only if relocation is dynamic, and is done at execution time
	- I/O problem
		- Latch job in memory while is involved in I/O
		- Do I/O only into OS buffers
- Now consider that backing store has same fragmentation problems
# Paging
- Physical address space of a process can be noncontiguous; process is allocated physical memory whenever the latter is available
	- Avoids external
	- Avoids problem of varying sized memory chunks
- Divide physical memory into fixed-sized blocks called **frames**
	- Size is power of 2, between 512 bytes and 16 Mbytes
	- Divide logical memory into blocks of same sizse called **pages**
	- Keep track of all free frames
# Structure of the Page Table
# Swapping
# Example: The Intel 32 and 64-bit Architectures
# Example: ARMv6 Architecture